import {existsSync} from "fs";
import {fileURLToPath} from "url";
import {dirname, join} from "path";
import {data, DescriptionDictionary, DescriptionPair, isDescriptionDictionary} from "@actions/expressions";
import {getEventPayload, getSupportedEventTypes} from "./eventPayloads";
import eventFilters from "./event-filters.json";

const DROPPED_EVENTS = new Set(eventFilters.dropped);

// Check if full webhooks file exists (generated by npm run update-webhooks)
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const fullWebhooksPath = join(__dirname, "webhooks.full.json");
const hasFullWebhooks = existsSync(fullWebhooksPath);

type Param = {
  name: string;
  description?: string;
  childParamsGroups?: Param[];
};

type FullAction = {
  action?: string;
  bodyParameters?: Param[];
};

type FullWebhooks = {
  [event: string]: {
    [action: string]: FullAction;
  };
};

describe("eventPayloads", () => {
  describe("getSupportedEventTypes", () => {
    it("returns action types for push event", () => {
      const types = getSupportedEventTypes("push");
      expect(types).toContain("default");
    });

    it("returns action types for issues event", () => {
      const types = getSupportedEventTypes("issues");
      expect(types.length).toBeGreaterThan(1);
      expect(types).toContain("opened");
      expect(types).toContain("closed");
    });
  });

  describe("getEventPayload", () => {
    it("returns payload for push event", () => {
      const payload = getEventPayload("push", "default");
      expect(payload).toBeDefined();

      // Verify common fields exist
      expect(payload?.get("ref")).toBeDefined();
      expect(payload?.get("repository")).toBeDefined();
      expect(payload?.get("sender")).toBeDefined();
    });

    it("returns payload for issues event", () => {
      const payload = getEventPayload("issues", "opened");
      expect(payload).toBeDefined();

      expect(payload?.get("action")).toBeDefined();
      expect(payload?.get("issue")).toBeDefined();
      expect(payload?.get("repository")).toBeDefined();
    });

    it("preserves descriptions for hover documentation", () => {
      // This test ensures bodyParameters[].description is not stripped
      // during JSON optimization. The description field is used for hover
      // documentation in the workflow editor.
      const payload = getEventPayload("push", "default");
      expect(payload).toBeDefined();

      // Get the description for a well-known field
      // repository should have a description like "A repository on GitHub"
      const repoDescription = payload?.getDescription("repository");
      expect(repoDescription).toBeDefined();
      expect(repoDescription?.length).toBeGreaterThan(0);

      // sender should have a description
      const senderDescription = payload?.getDescription("sender");
      expect(senderDescription).toBeDefined();
      expect(senderDescription?.length).toBeGreaterThan(0);
    });

    it("preserves childParamsGroups for nested property access", () => {
      // This test ensures bodyParameters[].childParamsGroups is not stripped
      // during JSON optimization. childParamsGroups defines nested properties
      // used for autocompletion like github.event.repository.owner.login
      const payload = getEventPayload("push", "default");
      expect(payload).toBeDefined();

      // repository has nested properties like owner, license, etc.
      const repository = payload?.get("repository") as DescriptionDictionary | undefined;
      expect(repository).toBeDefined();

      // repository.owner should exist (nested via childParamsGroups)
      const owner = repository?.get("owner") as DescriptionDictionary | undefined;
      expect(owner).toBeDefined();

      // repository.owner.login should exist (deeply nested)
      const login = owner?.get("login");
      expect(login).toBeDefined();
    });

    it("preserves name fields for property identification", () => {
      // This test ensures bodyParameters[].name is not stripped
      // during JSON optimization. The name field identifies each property.
      const payload = getEventPayload("issues", "opened");
      expect(payload).toBeDefined();

      // Verify well-known property names exist
      expect(payload?.get("action")).toBeDefined();
      expect(payload?.get("issue")).toBeDefined();
      expect(payload?.get("repository")).toBeDefined();
      expect(payload?.get("sender")).toBeDefined();

      // Verify nested property names work
      const issue = payload?.get("issue") as DescriptionDictionary | undefined;
      expect(issue?.get("title")).toBeDefined();
      expect(issue?.get("number")).toBeDefined();
      expect(issue?.get("user")).toBeDefined();
    });

    it("returns undefined for unknown event", () => {
      const payload = getEventPayload("not_a_real_event", "default");
      expect(payload).toBeUndefined();
    });
  });
});

// Optimization validation tests - only run if webhooks.full.json exists
// This file is generated by: npm run update-webhooks
// In CI, a separate job runs these tests after generating the file
const describeIfFullExists = hasFullWebhooks ? describe : describe.skip;

// Marker file path - written after validation tests complete
const fullValidationMarkerPath = join(__dirname, "webhooks.full.validation-complete");

describeIfFullExists("optimization validation", () => {
  let keptWebhooks: FullWebhooks;

  beforeAll(async () => {
    // Dynamically import the full webhooks file using fs to avoid TS module resolution
    const {readFileSync} = await import("fs");
    const fullWebhooks = JSON.parse(readFileSync(fullWebhooksPath, "utf-8")) as FullWebhooks;

    // Filter to only kept events
    keptWebhooks = {};
    for (const [event, actions] of Object.entries(fullWebhooks)) {
      if (!DROPPED_EVENTS.has(event)) {
        keptWebhooks[event] = actions;
      }
    }
  });

  afterAll(async () => {
    // Write marker file to prove validation tests ran
    const {writeFileSync} = await import("fs");
    writeFileSync(fullValidationMarkerPath, new Date().toISOString());
  });

  /**
   * Build a DescriptionDictionary from raw params (same logic as eventPayloads.ts)
   */
  function buildFromParams(params: Param[]): DescriptionDictionary {
    const d = new DescriptionDictionary();
    for (const param of params) {
      if (param.childParamsGroups && param.childParamsGroups.length > 0) {
        const child = buildFromParams(param.childParamsGroups);
        d.add(param.name, child, param.description);
      } else {
        // Match the behavior in eventPayloads.ts - don't overwrite existing
        if (!d.get(param.name)) {
          d.add(param.name, new data.Null(), param.description);
        }
      }
    }
    return d;
  }

  /**
   * Compare two DescriptionDictionary structures recursively
   */
  function compareStructures(full: DescriptionDictionary, optimized: DescriptionDictionary, path: string): string[] {
    const errors: string[] = [];

    const fullPairs = full.pairs();
    const optimizedPairs = optimized.pairs();

    const fullKeys = new Set(fullPairs.map((p: DescriptionPair) => p.key));
    const optimizedKeys = new Set(optimizedPairs.map((p: DescriptionPair) => p.key));

    // Check for missing keys in optimized
    for (const key of fullKeys) {
      if (!optimizedKeys.has(key)) {
        errors.push(`Missing key in optimized: ${path}.${key}`);
      }
    }

    // Check for extra keys in optimized
    for (const key of optimizedKeys) {
      if (!fullKeys.has(key)) {
        errors.push(`Extra key in optimized: ${path}.${key}`);
      }
    }

    // Compare descriptions and recurse into nested structures
    for (const fullPair of fullPairs) {
      const optimizedValue = optimized.get(fullPair.key);
      if (optimizedValue === undefined) continue;

      // Compare descriptions
      const fullDesc = full.getDescription(fullPair.key) ?? "";
      const optimizedDesc = optimized.getDescription(fullPair.key) ?? "";
      if (fullDesc !== optimizedDesc) {
        errors.push(
          `Description mismatch at ${path}.${fullPair.key}: ` + `full="${fullDesc}" vs optimized="${optimizedDesc}"`
        );
      }

      // Recurse into nested dictionaries
      if (isDescriptionDictionary(fullPair.value) && isDescriptionDictionary(optimizedValue)) {
        errors.push(...compareStructures(fullPair.value, optimizedValue, `${path}.${fullPair.key}`));
      }
    }

    return errors;
  }

  it("optimized webhooks match full source for all events and actions", () => {
    const allErrors: string[] = [];

    for (const [event, actions] of Object.entries(keptWebhooks)) {
      for (const [action, actionData] of Object.entries(actions)) {
        // Build from full source (use bodyParameters, may be undefined)
        const params = actionData.bodyParameters || [];
        const fullPayload = buildFromParams(params);

        // Get from optimized (deduplicated) source
        const optimizedPayload = getEventPayload(event, action);

        if (!optimizedPayload) {
          allErrors.push(`Missing optimized payload for ${event}.${action}`);
          continue;
        }

        const errors = compareStructures(fullPayload, optimizedPayload, `${event}.${action}`);
        allErrors.push(...errors);
      }
    }

    if (allErrors.length > 0) {
      fail(
        `Optimization validation failed:\n${allErrors.slice(0, 20).join("\n")}` +
          (allErrors.length > 20 ? `\n... and ${allErrors.length - 20} more errors` : "")
      );
    }
  });

  it("all full source events are present in optimized version", () => {
    for (const event of Object.keys(keptWebhooks)) {
      const types = getSupportedEventTypes(event);
      expect(types.length).toBeGreaterThan(0);
    }
  });

  it("all full source actions are present in optimized version", () => {
    for (const [event, actions] of Object.entries(keptWebhooks)) {
      for (const action of Object.keys(actions)) {
        const payload = getEventPayload(event, action);
        expect(payload).toBeDefined();
      }
    }
  });
});
